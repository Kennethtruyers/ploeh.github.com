---
layout: post
title: "Composition Root Reuse"
date: 2015-01-06 10:40 UTC
tags: [Software Design, Dependency Injection]
---
{% include JB/setup %}

<div id="post">
  <p>
    <em>A Composition Root is application-specific. It makes no sense to reuse it across code bases.</em>
  </p>
  <p>
    At regular intervals, I get questions about how to reuse <a href="http://blog.ploeh.dk/2011/07/28/CompositionRoot">Composition Roots</a>. The short answer is: <strong>you don't</strong>.
  </p>
  <p>
    Since it appears to be a Frequently Asked Question, it seems that a more detailed answer is warranted.
  </p>
  <p>
    <strong>Composition Roots define applications</strong>
  </p>
  <p>
    A Composition Root is application-specific; it's what <em>defines</em> a single application. After having written nice, decoupled code throughout your code base, the Composition Root is where you finally <em>couple</em> everything, from data access to (user) interfaces.
  </p>
  <p>
    Here's a simplified example:
  </p>
  <p>
    <pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">CompositionRoot</span>&nbsp;:&nbsp;<span style="color:#2b91af;">IHttpControllerActivator</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IHttpController</span>&nbsp;Create(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">HttpRequestMessage</span>&nbsp;request,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">HttpControllerDescriptor</span>&nbsp;controllerDescriptor,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Type</span>&nbsp;controllerType)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>(controllerType&nbsp;==&nbsp;<span style="color:blue;">typeof</span>(<span style="color:#2b91af;">ReservationsController</span>))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;ctx&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ReservationsContext</span>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;repository&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">SqlReservationRepository</span>(ctx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.RegisterForDispose(ctx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.RegisterForDispose(repository);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ReservationsController</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ApiValidator</span>(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repository,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Ma√ÆtreD</span>(10),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ReservationMapper</span>());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Handle&nbsp;more&nbsp;controller&nbsp;types&nbsp;here...</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentException</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#a31515;">&quot;Unknown&nbsp;Controller&nbsp;type:&nbsp;&quot;</span>&nbsp;+&nbsp;controllerType,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#a31515;">&quot;controllerType&quot;</span>);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
  </p>
  <p>
    This is an excerpt of a Composition Root for an ASP.NET Web API service, but the hosting framework isn't particularly important. What's important is that this piece of code pulls in objects from all over an application's code base in order to compose the application.
  </p>
  <p>
    The ReservationsContext class derives from <a href="http://msdn.microsoft.com/en-us/library/system.data.entity.dbcontext.aspx">DbContext</a>; an instance of it is injected into a SqlReservationRepository object. From this, it's clear that this application uses SQL Server for it data persistence. This decision is hard-coded into the Composition Root. You can't change this unless you recompile the Composition Root.
  </p>
  <p>
    At another boundary of this <a href="http://blog.ploeh.dk/2013/12/03/layers-onions-ports-adapters-its-all-the-same">hexagonal/onion/whatever architecture</a> is a ReservationsController, which derives from <a href="http://msdn.microsoft.com/en-us/library/system.web.http.apicontroller.aspx">ApiController</a>. From this, it's clear that this application is a REST API that uses ASP.NET Web API for its implementation. This decision, too, is hard-coded into the Composition Root.
  </p>
  <p>
    From this, it should be clear that the Composition Root is what <em>defines</em> the application. It combines all the loosely coupled components into an application: software that can be executed in an OS process.
  </p>
  <p>
    It makes no more sense to attempt to reuse a Composition Root than it does attempting to 'reuse' an application.
  </p>
  <p>
    <strong>Container-based Composition Roots</strong>
  </p>
  <p>
    The above example uses <a href="http://blog.ploeh.dk/2014/06/10/pure-di">Pure DI</a> in order to explain how a Composition Root is equivalent to an application definition. What about DI Container-based Composition Roots, then?
  </p>
  <p>
    It's essentially the same story, but with a twist. Imagine that you want to use Castle Windsor to compose your Web API; I've <a href="http://blog.ploeh.dk/2012/10/03/DependencyInjectioninASP.NETWebAPIwithCastleWindsor">already previously explained how to do that</a>, but here's the IHttpControllerActivator implementation repeated:
  </p>
  <p>
    <pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">WindsorCompositionRoot</span>&nbsp;:&nbsp;<span style="color:#2b91af;">IHttpControllerActivator</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">IWindsorContainer</span>&nbsp;container;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;WindsorCompositionRoot(<span style="color:#2b91af;">IWindsorContainer</span>&nbsp;container)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.container&nbsp;=&nbsp;container;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IHttpController</span>&nbsp;Create(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">HttpRequestMessage</span>&nbsp;request,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">HttpControllerDescriptor</span>&nbsp;controllerDescriptor,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Type</span>&nbsp;controllerType)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;controller&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:#2b91af;">IHttpController</span>)<span style="color:blue;">this</span>.container.Resolve(controllerType);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.RegisterForDispose(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Release</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;()&nbsp;=&gt;&nbsp;<span style="color:blue;">this</span>.container.Release(controller)));
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;controller;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Release</span>&nbsp;:&nbsp;<span style="color:#2b91af;">IDisposable</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">Action</span>&nbsp;release;
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Release(<span style="color:#2b91af;">Action</span>&nbsp;release)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.release&nbsp;=&nbsp;release;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Dispose()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.release();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
  </p>
  <p>
    Indeed, there's no application-specific code there; this class is completely reusable. However, this reusability is accomplished because the container is injected into the object. The container itself must be configured in order to work, and configuration code is just as application-specific as the above Pure DI example.
  </p>
  <p>
    Thus, with a DI Container, you may be able to decouple and reuse the part of the Composition Root that performs the <em>run-time</em> composition. However, the <em>design-time</em> composition is where you put the configuration code that select which concrete types should be used in which cases. This is the part that specifies the application, and that's not reusable.
  </p>
  <p>
    <strong>Summary</strong>
  </p>
  <p>
    Composition Roots aren't reusable.
  </p>
  <p>
    Sometimes, you might be building a suite of applications that share a substantial subset of dependencies. Imagine, for example, that you're building a REST API and a batch job that together solve a business problem. The Domain Model and the Data Access Layer may be shared between these two applications, but the boundary isn't. The batch job isn't going to need any Controllers, and the REST API isn't going to need whatever is going to kick off the batch job (e.g. a scheduler). These two applications may have a lot in common, but they're still <em>different</em>. Thus, they can't share a Composition Root.
  </p>
  <p>
    What about the DRY principle, then?
  </p>
  <p>
    Different applications have differing Composition Roots. Even if they start with substantial amounts of duplicated Composition Root code, in my experience, the 'common' code tends to diverge the more the applications are allowed to evolve. That duplication <a href="http://verraes.net/2014/08/dry-is-about-knowledge">may be accidental</a>, and <a href="http://programmer.97things.oreilly.com/wiki/index.php/Beware_the_Share">attempting to eliminate it may increase coupling</a>. It's better to <a href="http://blog.ploeh.dk/2014/08/07/why-dry">understand why you want to avoid duplication in the first place</a>.
  </p>
  <p>
    When it comes to Composition Roots, duplication tends to be accidental. Composition Roots aren't reusable.
  </p>
</div>
<div id="comments">
  <hr>
  <h2 id="comments-header">Comments</h2>
	<div class="comment">
    <div class="comment-author"><a href="http://www.kenneth-truyers.net">Kenneth Truyers</a></div>
    <div class="comment-content">
      I agree that composition roots should not be reused in general. However, there are exceptions to the rule. <br/>
      In the example where the domain layer and the data access layer are shared between applications, it really depends whether they will have a future need to be wired differently according to the application. <br />
      If that's not the case, you could argue that there's no need for two components either. <br />
      One solution would be to use a Facade which internally wires them up and exposes it as a single interface. This allows for reuse of the domain and the DAL as a single component, opaque to the client. 
    </div>
    <div class="comment-date">2015-01-06 13:06 UTC</div>
  </div>
  <div class="comment">
    <div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Kenneth, thank you for writing. If you create a Facade that internally wires up a Domain Model and DAL, you've created a tightly coupled bundle. What if you later discover that you need to <a href="http://blog.ploeh.dk/2010/09/20/InstrumentationwithDecoratorsandInterceptors">instrument your DAL</a>? You can't do that if you prematurely compose object graphs.
      </p>
      <p>
        Clearly, there are disadvantages to doing such a thing. What are the advantages?
      </p>
    </div>
    <div class="comment-date">2015-01-06 13:56 UTC</div>
  </div>
  <div class="comment">
    <div class="comment-author"><a href="http://www.kenneth-truyers.net">Kenneth Truyers</a></div>
    <div class="comment-content">
      <p>The advantage is that you can provide a single component to any type of application. There's no problem in instrumenting the DAL afterwards, you would just need to recompile the facade. </p>
      <p>Indeed, you create a tightly coupled bundle, but you'd only do this when the whole bundle needs to be opaque. When the client just uses it as a package, it also doesn't need to know anything about instrumentation.</p>
      <p>The same principle is actually very widely used. If you look at NuGet-packages, you see that often internally they use IoC, but externally they don't need to be wired up, since they wire everything up an then expose a single interface (a single conceptual interface, not a c#-interface per s√©).</p>
      <p>We can apply the same principle if the domain and DAL are frequently used together. It depends on the usage though. If in different applications you have different needs for instrumentation, then your article is 100% correct. However, if you know that all applications don't care about that and will always want the same behavior from the package, then you can wrap it up. (I'd even argue that in that case, you'd want to create a nuget package for it, but that's a separate issue)</p>
    </div>
    <div class="comment-date">2015-01-06 15:56 UTC</div>
  </div>
</div>
